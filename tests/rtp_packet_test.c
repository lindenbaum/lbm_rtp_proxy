/**
 * Copyright (C) 2015  Lindenbaum GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "tests.h"

#include "../src/rtp_packet.h"
#include "../src/rtcp_packet.h"

/*
// UDP
e8 89 80 01 00 20 d6 11
// RR
80 c9 00 01 c1 85 9f e9
// SDES
81 ca 00 03 c1 85 9f e9 01 04 53 4e 4f 4d 00 00
*/

uint8_t RR[] = {
  0xe8, 0x89, 0x80, 0x01, 0x00, 0x20, 0xd6, 0x11,
  0x80, 0xc9, 0x00, 0x01, 0xc1, 0x85, 0x9f, 0xe9,
  0x81, 0xca, 0x00, 0x03, 0xc1, 0x85, 0x9f, 0xe9,
  0x01, 0x04, 0x53, 0x4e, 0x4f, 0x4d, 0x00, 0x00,
};

/*
// UDP
e8 89 80 01 00 4c fc 1b
// SR
81 c8 00 0c c1 85 9f e9 00 00 8c b1 1e b8 00 00
00 00 00 00 00 00 00 f4 00 00 98 80 2a 6d 69 48
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00
// SDES
81 ca 00 03 c1 85 9f e9 01 04 53 4e 4f 4d 00 00
*/

uint8_t SR0[] = {
  0xe8, 0x89, 0x80, 0x01, 0x00, 0x4c, 0xfc, 0x1b,
  0x81, 0xc8, 0x00, 0x0c, 0xc1, 0x85, 0x9f, 0xe9,
  0x00, 0x00, 0x8c, 0xb1, 0x1e, 0xb8, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4,
  0x00, 0x00, 0x98, 0x80, 0x2a, 0x6d, 0x69, 0x48,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x81, 0xca, 0x00, 0x03,
  0xc1, 0x85, 0x9f, 0xe9, 0x01, 0x04, 0x53, 0x4e,
  0x4f, 0x4d, 0x00, 0x00,
};

/*
// UDP
e8 89 80 01 00 4c 5e dc
// SR
81 c8 00 0c c1 85 9f e9 00 00 8c b6 1e b8 00 00
00 00 00 00 00 00 01 ee 00 01 34 c0 2a 6d 69 48
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00
// SDES
81 ca 00 03 c1 85 9f e9 01 04 53 4e 4f 4d 00 00
*/

uint8_t SR1[] = {
  0xe8, 0x89, 0x80, 0x01, 0x00, 0x4c, 0x5e, 0xdc,
  0x81, 0xc8, 0x00, 0x0c, 0xc1, 0x85, 0x9f, 0xe9,
  0x00, 0x00, 0x8c, 0xb6, 0x1e, 0xb8, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xee,
  0x00, 0x01, 0x34, 0xc0, 0x2a, 0x6d, 0x69, 0x48,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x81, 0xca, 0x00, 0x03,
  0xc1, 0x85, 0x9f, 0xe9, 0x01, 0x04, 0x53, 0x4e,
  0x4f, 0x4d, 0x00, 0x00,
};

/*
// UDP
e8 89 80 01 00 1c 55 4d
// BYE
81 cb 00 04 c1 85 9f e9 0b 43 61 6c 6c 20 65 6e
64 65 64 00
*/

uint8_t BYE[] = {
  0xe8, 0x89, 0x80, 0x01, 0x00, 0x1c, 0x55, 0x4d,
  0x81, 0xcb, 0x00, 0x04, 0xc1, 0x85, 0x9f, 0xe9,
  0x0b, 0x43, 0x61, 0x6c, 0x6c, 0x20, 0x65, 0x6e,
  0x64, 0x65, 0x64, 0x00,
};

uint8_t rtp_data[] = {
  0x80, 0x08, 0x21, 0x55, 0x00, 0x00, 0x03, 0x20, 0x2a, 0x6d, 0x69, 0x48, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
  0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5, 0xd5,
};

void rewrite_rtcp_test(struct udphdr *udp_header, __be32 SSRC) {
  int32_t remaining = ntohs(udp_header->len);
  uint8_t *data = (uint8_t *)udp_header;
  if(remaining >= sizeof(struct udphdr)) {
    data += sizeof(struct udphdr);
    remaining -= sizeof(struct udphdr);
    while(remaining >= sizeof(struct rtcp_packet)) {
      struct rtcp_packet *packet = (struct rtcp_packet *)data;
      if(packet->V == 2) {
        switch(packet->PT) {
        case SR_PACKET_TYPE:
        case RR_PACKET_TYPE:
        case SDES_PACKET_TYPE:
        case BYE_PACKET_TYPE:
        case APP_PACKET_TYPE: {
          int32_t len = ((int32_t)ntohs(packet->length) + 1) * 4;
          packet->SSRC = SSRC;
          data += len;
          remaining -= len;
          break;
        }
        default:
          return;
        }
      }
      else {
        return;
      }
    }
  }
  else {
    return;
  }
}

int main(int argc, char **argv) {
  //printf("%d\n", sizeof(RR) / sizeof(RR[0]));
  assert_equals(htonl(0xc1859fe9), *(__be32 *)&RR[12], __FILE__, __LINE__);
  assert_equals(htonl(0xc1859fe9), *(__be32 *)&RR[20], __FILE__, __LINE__);
  rewrite_rtcp_test((struct udphdr *)RR, 0x12345678);
  assert_equals(0x12345678, *(__be32 *)&RR[12], __FILE__, __LINE__);
  assert_equals(0x12345678, *(__be32 *)&RR[20], __FILE__, __LINE__);

  assert_equals(htonl(0xc1859fe9), *(__be32 *)&SR0[12], __FILE__, __LINE__);
  assert_equals(htonl(0xc1859fe9), *(__be32 *)&SR0[64], __FILE__, __LINE__);
  rewrite_rtcp_test((struct udphdr *)SR0, 0x23456789);
  assert_equals(0x23456789, *(__be32 *)&SR0[12], __FILE__, __LINE__);
  assert_equals(0x23456789, *(__be32 *)&SR0[64], __FILE__, __LINE__);

  assert_equals(htonl(0xc1859fe9), *(__be32 *)&SR1[12], __FILE__, __LINE__);
  assert_equals(htonl(0xc1859fe9), *(__be32 *)&SR1[64], __FILE__, __LINE__);
  rewrite_rtcp_test((struct udphdr *)SR1, 0x3456789a);
  assert_equals(0x3456789a, *(__be32 *)&SR1[12], __FILE__, __LINE__);
  assert_equals(0x3456789a, *(__be32 *)&SR1[64], __FILE__, __LINE__);

  assert_equals(htonl(0xc1859fe9), *(__be32 *)&BYE[12], __FILE__, __LINE__);
  rewrite_rtcp_test((struct udphdr *)BYE, 0x456789ab);
  assert_equals(0x456789ab, *(__be32 *)&BYE[12], __FILE__, __LINE__);

  printf(KGRN"SUCCESS"KNRM"\n");
  exit(0);
}
